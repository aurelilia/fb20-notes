# Vorlesung am 18.10.2022
Compiler verbinden mehere Abstraktionsebenen; Umwandlung
High-Level (C, Smalltalk, etc.) zu Mid-Level Assembly
und Low-Level ISA

Komplexität der CPU entscheidet direkt Komplexität des Compilers.
(Our good friend Cell says hello!)  
Moderne Compiler sind für Performance wichtig (Hi LLVM!)

### Aufbau von Compilern
Pipeline eines Compilers generell:  
Source --Parsing--> AST --Semantic checking--> DAST --Codegen--> ASM

- Syntax durch AST dargestellt und validiert
- Semantic checking und Annotation weist Variablen zu und typechecked
- Variablen meistens fest Speicher im Stack zugewiesen (Optimization außen vor)
- Codegen zu Zielsprache, meist ASM


## Optimiernde Compiler
- Front-end: Syntax/semantics analysis/validation
- Middle-end: Transformation und Optimierung von IR (intermediate representation)
- Back-End: Erzeugen von Zielsprache

### Beispiele
- Constant Folding: `2 * 3 + y` -> `6 + y`
- Common Subexpression Elimination: `(2 + 2) + (2 + 2)` -> `t = 2 + 2; t + t`
- Strength Reduction: `for ... { i * 3 }`, Ersetzen der Multiplikation
  durch Addition in jedem Loop (Mul. langsam)
- Loop-invariant Code Motion: Code in Loop zu vor Loop verschieben,
  wenn Wert bei jeder Iteration gleich
